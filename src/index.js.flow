// @flow

type sentinelES5 = '@@AWA_SENTINEL';
const sentinelES6 = Symbol.for('awa.sentinel');
// TODO: Once flow gets Symbol support, remove typeof here.
type SENTINEL = sentinelES5 | typeof sentinelES6;

type FN<X, Y> = (domain: X) => Y;
type Maybe<T> = T | void;

type AwaValue<T> = T | SENTINEL;

declare class AwaIterable<T> {
  debug(): void;
  inspect(): string;

  @@iterator(): AwaIterator<T>;

  constructor <In,Out>(
    source: (Iterable<In> | AwaIterable<In>),
    transduce: (x: In) => Out, //FN<In, Out>,
    readyp: FN<mixed, boolean>,
    // TODO: It may be the case that we begin to add accumulators which
    // do not have the same type as the annotated output type for the
    // iterable. It may need to be left as mixed.
    initialAcc?: FN<mixed, Maybe<Out>>
  ): AwaIterable<Out>
}

export default {
  AwaIterable: AwaIterable
};

export {
  AwaIterable
}

export type {
  SENTINEL,
  AwaIteration
}
