// @flow

// Common & Helpers
declare type func = () => mixed;
declare type factory<T> = (...args: mixed[]) => T;

// Transducers
//declare type readyp<T> = boolean;
declare type reducingFn = <A, B>(acc: B, val: A) =>  B;
declare function transducingFn<A,B> (fn: func): reducingFn<A, B>;

declare type transducert<A, B> =
  // We would put as a type for fn (func) above, but that makes some
  // inferences in places we don't want them. For example, in spec
  // files, which we want to have with no annotations, we have some
  // tiny arrow functions, and as of now Flow cannot infer (x -> x * 2)
  // applied to an array of numbers is safe.
  //
  // So for now we use the unsafe `function` type.
  & (fn: function) => sequenceWrapper<A, B>
  & (fn: function, source?: Iterable<A>) => sequenceWrapper<A, B> | LazySequence<A, B>;
  

// Sequences
declare type sequenceWrapper<A, B> = <A,B>(LazySequence<mixed, A> | Iterable<A>) => LazySequence<A, B>;

